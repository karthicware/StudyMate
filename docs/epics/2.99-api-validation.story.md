# Story 2.99: Epic 2 API Validation with PostgreSQL MCP

## Status
Draft

## Story
**As a** QA Engineer,
**I want** all Epic 2 APIs validated end-to-end using PostgreSQL MCP with dummy data,
**so that** I can verify all booking, QR code, and check-in/out endpoints work correctly with real database interactions and capture evidence.

## Acceptance Criteria
1. Test data created in database using PostgreSQL MCP (users, seats, bookings, locks)
2. All Epic 2 endpoints tested with MCP-sourced data
3. Test results captured and documented in this story file
4. Authentication tested with student users from database
5. Booking authorization verified with database user records
6. Seat locking mechanism tested with concurrent scenarios
7. QR code generation and validation tested
8. Check-in/out time window logic verified (±15 minutes)
9. All edge cases tested (duplicate bookings, expired locks, invalid QR codes)
10. Database state verified after each operation

## Tasks / Subtasks
- [ ] Task 1: Setup test data using PostgreSQL MCP (AC: 1)
  - [ ] Create test student users (10 users for booking scenarios)
  - [ ] Create test study hall with owner
  - [ ] Create test seats (25 seats for availability testing)
  - [ ] Create test bookings in various states (CONFIRMED, COMPLETED, CANCELLED)
  - [ ] Create test seat locks (active and expired)
  - [ ] Capture INSERT results with row counts
- [ ] Task 2: Test authentication with student user (AC: 4)
  - [ ] Query test student credentials from database
  - [ ] Call POST /api/auth/login with database student user
  - [ ] Capture JWT token response
  - [ ] Verify token contains correct user info and STUDENT role
  - [ ] Document login response in story file
- [ ] Task 3: Test GET /student/seats/{hallId}/availability (AC: 2, 10)
  - [ ] Call endpoint with date range (start_date, end_date)
  - [ ] Verify response shows only available seats
  - [ ] Query database to verify seat statuses
  - [ ] Compare API response with database state
  - [ ] Test with fully booked date range
  - [ ] Capture API response and SQL query results
- [ ] Task 4: Test POST /student/seats/{seatId}/lock (AC: 2, 6, 10)
  - [ ] Call endpoint with available seat and student JWT token
  - [ ] Query database to verify lock created with 5-minute expiration
  - [ ] Verify lock contains user_id and expires_at timestamp
  - [ ] Test locking already-locked seat (should fail with 409)
  - [ ] Verify pessimistic locking prevents race conditions
  - [ ] Capture lock response and database verification
- [ ] Task 5: Test concurrent seat locking (AC: 6)
  - [ ] Setup scenario with 2 students attempting to lock same seat
  - [ ] Use PostgreSQL MCP to verify only ONE lock created
  - [ ] Query seat_locks table to confirm single lock exists
  - [ ] Verify second request receives 409 Conflict
  - [ ] Document race condition prevention
- [ ] Task 6: Test POST /student/bookings (AC: 2, 10)
  - [ ] Call endpoint with valid lock_id and seat_id
  - [ ] Query database to verify booking created with CONFIRMED status
  - [ ] Verify lock is released after booking creation
  - [ ] Test booking without valid lock (should fail with 400)
  - [ ] Test booking with expired lock (should fail with 400)
  - [ ] Capture booking response and database state
- [ ] Task 7: Test GET /student/bookings (AC: 2, 5)
  - [ ] Call endpoint with student JWT token
  - [ ] Verify response shows only bookings for authenticated student
  - [ ] Query database to confirm booking list matches
  - [ ] Test pagination (page=0, size=10)
  - [ ] Test filtering by status (status=CONFIRMED)
  - [ ] Capture response and SQL query results
- [ ] Task 8: Test DELETE /student/bookings/{bookingId} (AC: 2, 10)
  - [ ] Create test booking via database
  - [ ] Call endpoint to cancel booking
  - [ ] Query database to verify status changed to CANCELLED
  - [ ] Verify seat status updated to AVAILABLE
  - [ ] Test cancelling non-existent booking (404)
  - [ ] Test cancelling another user's booking (403)
  - [ ] Capture cancellation response and database state
- [ ] Task 9: Test GET /student/bookings/{bookingId}/qr-code (AC: 2, 7)
  - [ ] Create test booking with CONFIRMED status
  - [ ] Call endpoint to generate QR code
  - [ ] Verify response is valid PNG image
  - [ ] Decode QR code to verify it contains booking_id
  - [ ] Query database to confirm booking exists
  - [ ] Test QR generation for cancelled booking (should fail)
  - [ ] Capture QR code generation result
- [ ] Task 10: Test POST /student/bookings/check-in (AC: 2, 8, 10)
  - [ ] Create test booking with start_time within ±15 minutes of current time
  - [ ] Call endpoint with valid QR code data
  - [ ] Query database to verify check_in_time set
  - [ ] Test check-in too early (> 15 minutes before start) - should fail
  - [ ] Test check-in too late (> 15 minutes after start) - should fail
  - [ ] Test check-in with invalid QR code (400)
  - [ ] Capture check-in response and database verification
- [ ] Task 11: Test POST /student/bookings/check-out (AC: 2, 8, 10)
  - [ ] Use booking from check-in test
  - [ ] Call endpoint with valid QR code data
  - [ ] Query database to verify check_out_time set
  - [ ] Test check-out too early (> 15 minutes before end) - should fail
  - [ ] Test check-out without prior check-in (should fail)
  - [ ] Capture check-out response and database state
- [ ] Task 12: Test GET /student/dashboard (AC: 2)
  - [ ] Call endpoint with student JWT token
  - [ ] Verify response contains active booking info
  - [ ] Verify response contains upcoming bookings
  - [ ] Query database to validate dashboard data
  - [ ] Test with student who has no bookings
  - [ ] Capture dashboard response and SQL verification
- [ ] Task 13: Test authorization failures (AC: 5, 9)
  - [ ] Test student booking another student's seat lock (403)
  - [ ] Test cancelling another student's booking (403)
  - [ ] Test accessing booking without JWT token (401)
  - [ ] Test with expired token (401)
  - [ ] Capture error responses
- [ ] Task 14: Test edge cases (AC: 9)
  - [ ] Test seat availability with 100% occupancy
  - [ ] Test locking seat after lock just expired
  - [ ] Test QR code for completed booking
  - [ ] Test double check-in (should fail)
  - [ ] Test double check-out (should fail)
  - [ ] Query database to set up edge case scenarios
  - [ ] Capture responses for each scenario
- [ ] Task 15: Test scheduled lock expiration (AC: 6)
  - [ ] Create seat lock with expired timestamp
  - [ ] Wait for scheduled task to run (or trigger manually)
  - [ ] Query database to verify expired locks deleted
  - [ ] Verify seats become available after lock expiration
  - [ ] Document scheduled task behavior
- [ ] Task 16: Document all results in story file (AC: 3)
  - [ ] Add all SQL queries used
  - [ ] Add all API responses
  - [ ] Add database verification queries
  - [ ] Add screenshots or formatted output

## Dev Notes

### PostgreSQL MCP Integration
[Source: docs/architecture/studymate-system-architecture-blueprint.md#7-postgresql-mcp-integration-mandatory]
- **Database**: studymate_user
- **Credentials**: user=studymate_user, pwd=studymate_user
- **Tool**: `mcp__postgres__query`

### Test Data Setup Queries
Execute these via PostgreSQL MCP:

```sql
-- 1. Create test owner user
INSERT INTO users (email, password_hash, first_name, last_name, role)
VALUES ('owner@test.com', '$2a$10$...bcrypt_hash...', 'Test', 'Owner', 'OWNER')
RETURNING id, email, role;

-- 2. Create test student users (10 for various scenarios)
INSERT INTO users (email, password_hash, first_name, last_name, role)
VALUES
  ('student1@test.com', '$2a$10$...', 'Alice', 'Student', 'STUDENT'),
  ('student2@test.com', '$2a$10$...', 'Bob', 'Student', 'STUDENT'),
  ('student3@test.com', '$2a$10$...', 'Charlie', 'Student', 'STUDENT'),
  ('student4@test.com', '$2a$10$...', 'Diana', 'Student', 'STUDENT'),
  ('student5@test.com', '$2a$10$...', 'Eve', 'Student', 'STUDENT'),
  ('student6@test.com', '$2a$10$...', 'Frank', 'Student', 'STUDENT'),
  ('student7@test.com', '$2a$10$...', 'Grace', 'Student', 'STUDENT'),
  ('student8@test.com', '$2a$10$...', 'Henry', 'Student', 'STUDENT'),
  ('student9@test.com', '$2a$10$...', 'Ivy', 'Student', 'STUDENT'),
  ('student10@test.com', '$2a$10$...', 'Jack', 'Student', 'STUDENT')
RETURNING id, email;

-- 3. Create test study hall (use owner_id from step 1)
INSERT INTO study_halls (owner_id, hall_name, seat_count, address)
VALUES (1, 'Test Study Hall', 25, '456 Booking Test Street, Test City')
RETURNING id, hall_name, seat_count;

-- 4. Create test seats (25 seats for availability testing)
INSERT INTO seats (hall_id, seat_number, x_coord, y_coord, status)
VALUES
  (1, 'A1', 10, 20, 'AVAILABLE'),
  (1, 'A2', 10, 40, 'AVAILABLE'),
  (1, 'A3', 10, 60, 'AVAILABLE'),
  (1, 'A4', 10, 80, 'AVAILABLE'),
  (1, 'A5', 10, 100, 'AVAILABLE'),
  (1, 'B1', 30, 20, 'AVAILABLE'),
  (1, 'B2', 30, 40, 'AVAILABLE'),
  (1, 'B3', 30, 60, 'AVAILABLE'),
  (1, 'B4', 30, 80, 'AVAILABLE'),
  (1, 'B5', 30, 100, 'AVAILABLE'),
  (1, 'C1', 50, 20, 'AVAILABLE'),
  (1, 'C2', 50, 40, 'AVAILABLE'),
  (1, 'C3', 50, 60, 'AVAILABLE'),
  (1, 'C4', 50, 80, 'AVAILABLE'),
  (1, 'C5', 50, 100, 'AVAILABLE'),
  (1, 'D1', 70, 20, 'AVAILABLE'),
  (1, 'D2', 70, 40, 'AVAILABLE'),
  (1, 'D3', 70, 60, 'AVAILABLE'),
  (1, 'D4', 70, 80, 'AVAILABLE'),
  (1, 'D5', 70, 100, 'AVAILABLE'),
  (1, 'E1', 90, 20, 'AVAILABLE'),
  (1, 'E2', 90, 40, 'AVAILABLE'),
  (1, 'E3', 90, 60, 'AVAILABLE'),
  (1, 'E4', 90, 80, 'AVAILABLE'),
  (1, 'E5', 90, 100, 'AVAILABLE')
RETURNING id, seat_number, status;

-- 5. Create test bookings in various states
INSERT INTO bookings (user_id, seat_id, start_time, end_time, status, check_in_time, check_out_time)
VALUES
  -- Active bookings (CONFIRMED)
  (2, 1, '2025-10-11 09:00:00', '2025-10-11 18:00:00', 'CONFIRMED', NULL, NULL),
  (3, 2, '2025-10-11 09:00:00', '2025-10-11 18:00:00', 'CONFIRMED', NULL, NULL),
  (4, 3, '2025-10-12 09:00:00', '2025-10-12 18:00:00', 'CONFIRMED', NULL, NULL),
  -- Completed bookings
  (5, 4, '2025-10-09 09:00:00', '2025-10-09 18:00:00', 'COMPLETED', '2025-10-09 09:05:00', '2025-10-09 17:55:00'),
  (6, 5, '2025-10-08 09:00:00', '2025-10-08 18:00:00', 'COMPLETED', '2025-10-08 09:10:00', '2025-10-08 17:50:00'),
  -- Cancelled bookings
  (7, 6, '2025-10-13 09:00:00', '2025-10-13 18:00:00', 'CANCELLED', NULL, NULL)
RETURNING id, user_id, seat_id, status;

-- 6. Create test seat locks (active and expired)
INSERT INTO seat_locks (seat_id, user_id, expires_at)
VALUES
  -- Active lock (expires 5 minutes from now)
  (10, 8, CURRENT_TIMESTAMP + INTERVAL '5 minutes'),
  -- Expired lock (expired 2 minutes ago)
  (11, 9, CURRENT_TIMESTAMP - INTERVAL '2 minutes')
RETURNING id, seat_id, user_id, expires_at;
```

### Validation Queries

**Verify Seat Availability:**
```sql
-- Get available seats for date range
SELECT s.id, s.seat_number, s.status
FROM seats s
WHERE s.hall_id = 1
  AND s.id NOT IN (
    SELECT b.seat_id
    FROM bookings b
    WHERE b.status = 'CONFIRMED'
      AND b.start_time < '2025-10-11 18:00:00'
      AND b.end_time > '2025-10-11 09:00:00'
  )
ORDER BY s.seat_number;
```

**Verify Seat Lock Creation:**
```sql
-- Check seat lock exists and is valid
SELECT
  sl.id,
  sl.seat_id,
  sl.user_id,
  sl.expires_at,
  CASE
    WHEN sl.expires_at > CURRENT_TIMESTAMP THEN 'ACTIVE'
    ELSE 'EXPIRED'
  END as lock_status
FROM seat_locks sl
WHERE sl.seat_id = ? AND sl.user_id = ?
ORDER BY sl.created_at DESC
LIMIT 1;
```

**Verify Booking Creation:**
```sql
-- Confirm booking exists with correct status
SELECT
  b.id,
  b.user_id,
  b.seat_id,
  b.start_time,
  b.end_time,
  b.status,
  b.check_in_time,
  b.check_out_time,
  s.seat_number
FROM bookings b
JOIN seats s ON b.seat_id = s.id
WHERE b.id = ?;
```

**Verify Check-In Time Window:**
```sql
-- Validate check-in timing (±15 minutes from start_time)
SELECT
  b.id,
  b.start_time,
  b.check_in_time,
  EXTRACT(EPOCH FROM (b.check_in_time - b.start_time)) / 60 as minutes_difference,
  CASE
    WHEN b.check_in_time BETWEEN (b.start_time - INTERVAL '15 minutes')
         AND (b.start_time + INTERVAL '15 minutes') THEN 'VALID'
    ELSE 'INVALID'
  END as timing_status
FROM bookings b
WHERE b.id = ?;
```

**Verify QR Code Data:**
```sql
-- Confirm booking exists for QR code generation
SELECT
  b.id as booking_id,
  b.status,
  u.email,
  u.first_name,
  u.last_name,
  s.seat_number,
  b.start_time,
  b.end_time
FROM bookings b
JOIN users u ON b.user_id = u.id
JOIN seats s ON b.seat_id = s.id
WHERE b.id = ? AND b.status = 'CONFIRMED';
```

**Verify Student Dashboard Data:**
```sql
-- Get student's active and upcoming bookings
SELECT
  b.id,
  s.seat_number,
  sh.hall_name,
  b.start_time,
  b.end_time,
  b.status,
  b.check_in_time,
  CASE
    WHEN b.start_time <= CURRENT_TIMESTAMP AND b.end_time >= CURRENT_TIMESTAMP THEN 'ACTIVE'
    WHEN b.start_time > CURRENT_TIMESTAMP THEN 'UPCOMING'
    ELSE 'PAST'
  END as booking_state
FROM bookings b
JOIN seats s ON b.seat_id = s.id
JOIN study_halls sh ON s.hall_id = sh.id
WHERE b.user_id = ? AND b.status = 'CONFIRMED'
ORDER BY b.start_time;
```

### API Testing Template

For each endpoint, document:
1. **Setup**: SQL queries to prepare test data
2. **Request**: HTTP method, URL, headers, body
3. **Response**: Status code, response body
4. **Verification**: SQL queries to verify database state
5. **Teardown**: SQL queries to clean up (if needed)

## Test Results

### Test Data Setup Results
```
_To be filled by QA Agent during testing_

Example format:
=================================================
SQL Query:
INSERT INTO users (email, password_hash, first_name, last_name, role)
VALUES ('student1@test.com', '$2a$10$...', 'Alice', 'Student', 'STUDENT')
RETURNING id, email, role;

Result:
 id |        email         |   role
----+----------------------+---------
  2 | student1@test.com    | STUDENT
(1 row)
=================================================
```

### Authentication Test Results (Student User)
```
_To be filled by QA Agent_

Request:
POST /api/auth/login
Content-Type: application/json

{
  "email": "student1@test.com",
  "password": "test123"
}

Response (200 OK):
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "email": "student1@test.com",
  "role": "STUDENT"
}

Verification SQL:
SELECT email, role FROM users WHERE email = 'student1@test.com';

Result: ✅ User found, credentials match, STUDENT role confirmed
```

### GET /student/seats/{hallId}/availability Test Results
```
_To be filled by QA Agent_

Request:
GET /student/seats/1/availability?start_date=2025-10-11T09:00:00&end_date=2025-10-11T18:00:00
Authorization: Bearer <student_token>

Response (200 OK):
{
  "availableSeats": [
    {"seatId": 4, "seatNumber": "A4", "coordinates": {"x": 10, "y": 80}},
    {"seatId": 5, "seatNumber": "A5", "coordinates": {"x": 10, "y": 100}},
    ...
  ],
  "totalAvailable": 22
}

Verification SQL:
[Seat availability query for date range]

Result: ✅ All available seats returned, occupied seats excluded
```

### POST /student/seats/{seatId}/lock Test Results
```
_To be filled by QA Agent_

Request:
POST /student/seats/15/lock
Authorization: Bearer <student_token>

Response (200 OK):
{
  "lockId": 123,
  "seatId": 15,
  "expiresAt": "2025-10-11T10:35:00"
}

Verification SQL:
SELECT id, seat_id, user_id, expires_at
FROM seat_locks
WHERE seat_id = 15 AND user_id = 2
ORDER BY created_at DESC LIMIT 1;

Result: ✅ Lock created with 5-minute expiration, user_id matches authenticated user

Test: Concurrent Lock Attempt
Request: POST /student/seats/15/lock (from different user)
Response: 409 Conflict
Result: ✅ Pessimistic locking prevents race condition
```

### POST /student/bookings Test Results
```
_To be filled by QA Agent_

Request:
POST /student/bookings
Authorization: Bearer <student_token>
Content-Type: application/json

{
  "seatId": 15,
  "lockId": 123,
  "startTime": "2025-10-11T09:00:00",
  "endTime": "2025-10-11T18:00:00"
}

Response (201 Created):
{
  "bookingId": 456,
  "seatNumber": "C5",
  "status": "CONFIRMED",
  "startTime": "2025-10-11T09:00:00",
  "endTime": "2025-10-11T18:00:00"
}

Verification SQL:
SELECT id, user_id, seat_id, status FROM bookings WHERE id = 456;
SELECT * FROM seat_locks WHERE id = 123;

Result: ✅ Booking created with CONFIRMED status, lock released after booking
```

### GET /student/bookings Test Results
```
_To be filled by QA Agent_
```

### DELETE /student/bookings/{bookingId} Test Results
```
_To be filled by QA Agent_
```

### GET /student/bookings/{bookingId}/qr-code Test Results
```
_To be filled by QA Agent_

Request:
GET /student/bookings/456/qr-code
Authorization: Bearer <student_token>

Response (200 OK):
Content-Type: image/png
[PNG binary data]

Verification:
- QR code decoded successfully
- Contains booking ID: 456
- Booking status in database: CONFIRMED

Result: ✅ QR code generated and contains correct booking information
```

### POST /student/bookings/check-in Test Results
```
_To be filled by QA Agent_

Setup SQL:
UPDATE bookings SET start_time = CURRENT_TIMESTAMP + INTERVAL '5 minutes'
WHERE id = 456;

Request:
POST /student/bookings/check-in
Authorization: Bearer <student_token>
Content-Type: application/json

{
  "qrData": "booking_id:456"
}

Response (200 OK):
{
  "message": "Check-in successful",
  "checkInTime": "2025-10-11T09:05:32"
}

Verification SQL:
SELECT check_in_time, start_time,
  EXTRACT(EPOCH FROM (check_in_time - start_time)) / 60 as minutes_diff
FROM bookings WHERE id = 456;

Result: ✅ Check-in time recorded, within ±15 minute window

Test: Check-in too early (> 15 minutes before)
Response: 400 Bad Request - "Check-in too early"
Result: ✅ Time window validation working
```

### POST /student/bookings/check-out Test Results
```
_To be filled by QA Agent_
```

### GET /student/dashboard Test Results
```
_To be filled by QA Agent_
```

### Authorization Failure Tests
```
_To be filled by QA Agent_

Test: Student booking another student's lock
Request: POST /student/bookings (with lock_id owned by different user)
Response: 403 Forbidden
Result: ✅ Authorization prevents using another user's lock

Test: Student cancelling another student's booking
Request: DELETE /student/bookings/999 (owned by different user)
Response: 403 Forbidden
Result: ✅ Authorization working correctly

Test: No JWT token
Request: GET /student/bookings (no Authorization header)
Response: 401 Unauthorized
Result: ✅ Authentication required
```

### Edge Case Tests
```
_To be filled by QA Agent_

Test: Seat availability with 100% occupancy
Setup SQL: [Create bookings for all 25 seats]
Response: { "availableSeats": [], "totalAvailable": 0 }
Result: ✅ Handles fully booked hall correctly

Test: Locking seat after lock just expired
Setup SQL: DELETE FROM seat_locks WHERE expires_at < CURRENT_TIMESTAMP;
Response: 200 OK - Lock created successfully
Result: ✅ Expired locks don't block new locks

Test: QR code for completed booking
Request: GET /student/bookings/{completed_booking_id}/qr-code
Response: 400 Bad Request
Result: ✅ QR codes only generated for CONFIRMED bookings

Test: Double check-in
Request: POST /student/bookings/check-in (booking already checked in)
Response: 400 Bad Request - "Already checked in"
Result: ✅ Prevents duplicate check-ins
```

### Scheduled Lock Expiration Test
```
_To be filled by QA Agent_

Setup SQL:
INSERT INTO seat_locks (seat_id, user_id, expires_at)
VALUES (20, 10, CURRENT_TIMESTAMP - INTERVAL '10 minutes');

Wait: [Trigger scheduled task or wait for next run]

Verification SQL:
SELECT COUNT(*) FROM seat_locks WHERE expires_at < CURRENT_TIMESTAMP;

Result: ✅ Expired locks cleaned up by scheduled task, seats available again
```

## Testing Checklist

- [ ] All test data created successfully in database
- [ ] All SQL queries documented with results
- [ ] All API requests documented with responses
- [ ] All database verifications performed
- [ ] Seat locking mechanism tested with concurrent scenarios
- [ ] QR code generation and decoding verified
- [ ] Check-in/out time window logic validated (±15 minutes)
- [ ] All edge cases tested
- [ ] All authorization scenarios tested
- [ ] Scheduled lock expiration tested
- [ ] All results captured in this story file
- [ ] Database cleaned up after testing (optional)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-11 | 1.0 | Epic 2 API validation story created | Bob (Scrum Master) |

## QA Agent Record

### Test Execution Date
_To be filled by QA Agent_

### Test Environment
- Database: studymate_user (PostgreSQL)
- Backend URL: http://localhost:8080
- PostgreSQL MCP: Connected ✅

### Overall Test Results
- Total Endpoints Tested: __/10
- Passed: __
- Failed: __
- Blocked: __

### Issues Found
_To be filled by QA Agent_

### Evidence Files
_Screenshots, exported SQL results, API response logs, QR code samples_
