# Story 2.1.1-backend: Gender-Based Booking Validation (Backend)

## Story Metadata

| Field | Value |
|-------|-------|
| **Story ID** | 2.1.1-backend |
| **Story Name** | Gender-Based Booking Validation (Backend) |
| **Epic** | Epic 2: Student Booking & Seat Management |
| **Feature** | Feature 2.1: Seat Booking API (Enhancement) |
| **Story Type** | Backend Development |
| **Priority** | High (Phase 4 of Ladies-Only Implementation) |
| **Status** | Draft |
| **Estimated Story Points** | 2 SP |
| **Sprint** | TBD (Phase 4 of Ladies-Only Implementation) |
| **Assigned To** | Unassigned |
| **Created Date** | 2025-10-14 |
| **Updated Date** | 2025-10-14 |
| **Related Change Proposal** | Sprint Change Proposal A: Ladies-Only Seats (SCP-2025-10-14-001) |

---

## User Story

**As a** System,
**I want** to validate that only female users can book ladies-only seats at the API level
**so that** gender-based booking restrictions are enforced server-side for security and data integrity.

---

## Story Description

This story implements backend validation in the booking API to enforce ladies-only seat restrictions. When a student attempts to book a ladies-only seat, the system validates their gender from the JWT token against the seat's `isLadiesOnly` flag. If the user is not female and the seat is ladies-only, the API returns a 403 Forbidden error with a clear message. This provides a critical backend safeguard even if frontend validation is bypassed.

**Context**:
- Part of Sprint Change Proposal A: Ladies-Only Seats Configuration
- Depends on Stories 0.1.5-backend, 1.4.1, and 2.18.1 being complete
- Provides server-side validation as final enforcement layer
- Prevents API manipulation attempts to bypass frontend validation

**Validation Logic**:
- **FEMALE users**: Can book any seat (including ladies-only)
- **MALE users**: Cannot book ladies-only seats (return 403)
- **OTHER users**: Cannot book ladies-only seats (return 403)
- **PREFER_NOT_TO_SAY users**: Cannot book ladies-only seats (return 403)
- **No gender set (null)**: Cannot book ladies-only seats (return 403)
- **Regular seats**: All users can book regardless of gender

**Security Considerations**:
- JWT token gender claim is trusted source of truth
- Gender validated before seat is locked or booked
- Atomic transaction ensures seat state consistency
- Prevents race conditions via database-level seat locking

[Source: Sprint Change Proposal A, Section 8 - Phase 4]

---

## Acceptance Criteria

### AC1: Backend Validates Gender Before Booking Ladies-Only Seat
**Given** a student attempts to book a seat via `POST /api/booking/create`
**When** the API receives the booking request
**Then** the system:
- Extracts user gender from JWT token
- Retrieves seat data (including `isLadiesOnly` flag)
- Validates: If `isLadiesOnly == true`, user gender MUST be FEMALE
- Allows booking if validation passes
- Returns 403 Forbidden if validation fails

**Testing**:
- [ ] Female users can book ladies-only seats
- [ ] Male users cannot book ladies-only seats (403 error)
- [ ] Users without gender cannot book ladies-only seats (403 error)
- [ ] Users with OTHER/PREFER_NOT_TO_SAY cannot book ladies-only seats (403 error)
- [ ] All users can book regular seats

[Source: Sprint Change Proposal A, Section 7 - Backend Validation]

---

### AC2: API Returns 403 with Clear Error Message
**Given** a non-female user attempts to book a ladies-only seat
**When** the backend validation fails
**Then** the system returns:
- HTTP Status: 403 Forbidden
- Error message: "This seat is reserved for female users only. Please select a different seat."
- Error code: "LADIES_ONLY_SEAT_RESTRICTION"
- Seat ID in response

**Response Example**:
```json
{
  "timestamp": "2025-10-14T12:34:56Z",
  "status": 403,
  "error": "Forbidden",
  "message": "This seat is reserved for female users only. Please select a different seat.",
  "errorCode": "LADIES_ONLY_SEAT_RESTRICTION",
  "path": "/api/booking/create",
  "seatId": "uuid-123"
}
```

**Testing**:
- [ ] 403 status code returned
- [ ] Error message clear and user-friendly
- [ ] Error code included for frontend handling
- [ ] Seat ID included in response

[Source: Sprint Change Proposal A, Section 7 - Backend Validation]

---

### AC3: Gender Retrieved from JWT Token Claims
**Given** a booking API request includes a JWT token
**When** the system validates the booking
**Then** the system:
- Extracts `gender` claim from JWT token
- Handles missing gender claim (treat as null)
- Logs error if JWT is invalid or expired
- Returns 401 Unauthorized if JWT is invalid

**JWT Token Payload Example**:
```json
{
  "sub": "user-id",
  "email": "student@example.com",
  "role": "STUDENT",
  "gender": "FEMALE",
  "exp": 1234567890
}
```

**Testing**:
- [ ] Gender extracted from JWT claims
- [ ] Missing gender treated as null (fails validation)
- [ ] Invalid JWT returns 401
- [ ] Expired JWT returns 401

[Source: Sprint Change Proposal A, Section 7 - Backend Validation]

---

### AC4: Validation Occurs Before Seat Lock
**Given** a booking request is processed
**When** the system validates ladies-only seat restriction
**Then** the system:
- Performs validation BEFORE seat is locked
- Does NOT lock seat if validation fails
- Does NOT create booking record if validation fails
- Ensures seat remains available for valid users

**Transaction Flow**:
1. Extract user gender from JWT
2. Retrieve seat data
3. **Validate ladies-only restriction** ← THIS STEP
4. Lock seat (if validation passes)
5. Create booking record
6. Commit transaction

**Testing**:
- [ ] Validation occurs before seat lock
- [ ] Failed validation does not lock seat
- [ ] Failed validation does not create booking
- [ ] Seat remains available after failed validation

[Source: Sprint Change Proposal A, Section 7 - Backend Validation]

---

### AC5: Regular Seats Allow All Users
**Given** a student attempts to book a regular (non-ladies-only) seat
**When** the API processes the booking request
**Then** the system:
- Skips ladies-only validation for regular seats
- Allows booking regardless of user gender
- Processes booking normally

**Testing**:
- [ ] Male users can book regular seats
- [ ] Female users can book regular seats
- [ ] Users without gender can book regular seats
- [ ] No 403 error for regular seats

[Source: Sprint Change Proposal A, Section 7 - Backend Validation]

---

### AC6: Logging and Monitoring for Failed Attempts
**Given** a non-female user attempts to book a ladies-only seat
**When** the validation fails
**Then** the system:
- Logs the failed attempt with user ID, seat ID, and reason
- Increments monitoring metric: `booking_validation_failures`
- Log level: INFO (not ERROR, as this is expected behavior)
- Does NOT log sensitive user data (only IDs)

**Log Example**:
```
INFO: Ladies-only seat booking validation failed | userId=uuid-abc, seatId=uuid-123, userGender=MALE, reason=LADIES_ONLY_SEAT_RESTRICTION
```

**Testing**:
- [ ] Failed attempts logged
- [ ] Log includes user ID and seat ID
- [ ] Log includes reason
- [ ] No sensitive data logged

[Source: Sprint Change Proposal A, Section 11 - Monitoring]

---

## Technical Implementation Details

### Backend Implementation

**1. Booking Service Update**

File: `studymate-backend/src/main/java/com/studymate/backend/service/BookingService.java`
```java
package com.studymate.backend.service;

import com.studymate.backend.dto.BookingCreateRequest;
import com.studymate.backend.dto.BookingCreateResponse;
import com.studymate.backend.exception.LadiesOnlySeatRestrictionException;
import com.studymate.backend.model.Booking;
import com.studymate.backend.model.Seat;
import com.studymate.backend.model.User;
import com.studymate.backend.model.User.Gender;
import com.studymate.backend.repository.BookingRepository;
import com.studymate.backend.repository.SeatRepository;
import com.studymate.backend.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class BookingService {

    private final BookingRepository bookingRepository;
    private final SeatRepository seatRepository;
    private final UserRepository userRepository;

    /**
     * Create a new booking with ladies-only seat validation
     */
    @Transactional
    public BookingCreateResponse createBooking(BookingCreateRequest request, String userId) {
        // Retrieve user
        User user = userRepository.findById(UUID.fromString(userId))
                .orElseThrow(() -> new RuntimeException("User not found"));

        // Retrieve seat
        Seat seat = seatRepository.findById(UUID.fromString(request.getSeatId()))
                .orElseThrow(() -> new RuntimeException("Seat not found"));

        // NEW: Validate ladies-only seat restriction
        validateLadiesOnlySeatRestriction(user, seat);

        // Check seat availability
        if (!"AVAILABLE".equals(seat.getStatus())) {
            throw new RuntimeException("Seat is not available");
        }

        // Lock seat
        seat.setStatus("LOCKED");
        seatRepository.save(seat);

        // Create booking
        Booking booking = new Booking();
        booking.setUser(user);
        booking.setSeat(seat);
        booking.setHallId(seat.getStudyHall().getId());
        booking.setBookingDate(request.getBookingDate());
        booking.setStatus("PENDING");

        Booking savedBooking = bookingRepository.save(booking);

        log.info("Booking created successfully | userId={}, seatId={}, bookingId={}",
                userId, seat.getId(), savedBooking.getId());

        return BookingCreateResponse.builder()
                .bookingId(savedBooking.getId().toString())
                .message("Booking created successfully")
                .build();
    }

    /**
     * NEW: Validate ladies-only seat restriction
     */
    private void validateLadiesOnlySeatRestriction(User user, Seat seat) {
        // Skip validation for regular seats
        if (!Boolean.TRUE.equals(seat.getIsLadiesOnly())) {
            return;
        }

        // Extract user gender
        Gender userGender = user.getGender();

        // FEMALE users can book ladies-only seats
        if (Gender.FEMALE.equals(userGender)) {
            return;
        }

        // All other cases: reject booking
        log.info("Ladies-only seat booking validation failed | userId={}, seatId={}, userGender={}, reason=LADIES_ONLY_SEAT_RESTRICTION",
                user.getId(), seat.getId(), userGender);

        throw new LadiesOnlySeatRestrictionException(
                "This seat is reserved for female users only. Please select a different seat.",
                seat.getId().toString()
        );
    }
}
```

**2. Custom Exception for Ladies-Only Restriction**

File: `studymate-backend/src/main/java/com/studymate/backend/exception/LadiesOnlySeatRestrictionException.java`
```java
package com.studymate.backend.exception;

import lombok.Getter;

@Getter
public class LadiesOnlySeatRestrictionException extends RuntimeException {

    private final String errorCode = "LADIES_ONLY_SEAT_RESTRICTION";
    private final String seatId;

    public LadiesOnlySeatRestrictionException(String message, String seatId) {
        super(message);
        this.seatId = seatId;
    }
}
```

**3. Global Exception Handler Update**

File: `studymate-backend/src/main/java/com/studymate/backend/exception/GlobalExceptionHandler.java`
```java
package com.studymate.backend.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.Instant;
import java.util.LinkedHashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    // ... existing exception handlers ...

    /**
     * NEW: Handle ladies-only seat restriction exception
     */
    @ExceptionHandler(LadiesOnlySeatRestrictionException.class)
    public ResponseEntity<Map<String, Object>> handleLadiesOnlySeatRestriction(
            LadiesOnlySeatRestrictionException ex) {

        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", Instant.now().toString());
        body.put("status", HttpStatus.FORBIDDEN.value());
        body.put("error", HttpStatus.FORBIDDEN.getReasonPhrase());
        body.put("message", ex.getMessage());
        body.put("errorCode", ex.getErrorCode());
        body.put("seatId", ex.getSeatId());

        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(body);
    }
}
```

**4. JWT Extraction Helper (if not exists)**

File: `studymate-backend/src/main/java/com/studymate/backend/security/JwtUtils.java`
```java
package com.studymate.backend.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import org.springframework.stereotype.Component;

@Component
public class JwtUtils {

    private final String SECRET_KEY = "your-secret-key"; // Use environment variable in production

    /**
     * Extract user ID from JWT token
     */
    public String extractUserId(String token) {
        Claims claims = extractAllClaims(token);
        return claims.getSubject();
    }

    /**
     * Extract gender from JWT token
     */
    public String extractGender(String token) {
        Claims claims = extractAllClaims(token);
        return claims.get("gender", String.class);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(SECRET_KEY)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }
}
```

[Source: Sprint Change Proposal A, Section 7 - Backend Validation]

---

## Testing Requirements

### Backend Unit Tests

**Service Tests**:
```java
@SpringBootTest
class BookingServiceTest {

    @Autowired
    private BookingService bookingService;

    @MockBean
    private UserRepository userRepository;

    @MockBean
    private SeatRepository seatRepository;

    @MockBean
    private BookingRepository bookingRepository;

    @Test
    void shouldAllowFemaleUserToBookLadiesOnlySeat() {
        // Arrange
        User femaleUser = new User();
        femaleUser.setId(UUID.randomUUID());
        femaleUser.setGender(Gender.FEMALE);

        Seat ladiesSeat = new Seat();
        ladiesSeat.setId(UUID.randomUUID());
        ladiesSeat.setIsLadiesOnly(true);
        ladiesSeat.setStatus("AVAILABLE");

        when(userRepository.findById(any())).thenReturn(Optional.of(femaleUser));
        when(seatRepository.findById(any())).thenReturn(Optional.of(ladiesSeat));
        when(bookingRepository.save(any())).thenAnswer(i -> i.getArgument(0));

        BookingCreateRequest request = new BookingCreateRequest();
        request.setSeatId(ladiesSeat.getId().toString());

        // Act & Assert
        assertDoesNotThrow(() -> bookingService.createBooking(request, femaleUser.getId().toString()));
    }

    @Test
    void shouldRejectMaleUserFromBookingLadiesOnlySeat() {
        // Arrange
        User maleUser = new User();
        maleUser.setId(UUID.randomUUID());
        maleUser.setGender(Gender.MALE);

        Seat ladiesSeat = new Seat();
        ladiesSeat.setId(UUID.randomUUID());
        ladiesSeat.setIsLadiesOnly(true);
        ladiesSeat.setStatus("AVAILABLE");

        when(userRepository.findById(any())).thenReturn(Optional.of(maleUser));
        when(seatRepository.findById(any())).thenReturn(Optional.of(ladiesSeat));

        BookingCreateRequest request = new BookingCreateRequest();
        request.setSeatId(ladiesSeat.getId().toString());

        // Act & Assert
        assertThrows(LadiesOnlySeatRestrictionException.class, () ->
                bookingService.createBooking(request, maleUser.getId().toString())
        );
    }

    @Test
    void shouldRejectUserWithoutGenderFromBookingLadiesOnlySeat() {
        // Arrange
        User userWithoutGender = new User();
        userWithoutGender.setId(UUID.randomUUID());
        userWithoutGender.setGender(null);

        Seat ladiesSeat = new Seat();
        ladiesSeat.setId(UUID.randomUUID());
        ladiesSeat.setIsLadiesOnly(true);
        ladiesSeat.setStatus("AVAILABLE");

        when(userRepository.findById(any())).thenReturn(Optional.of(userWithoutGender));
        when(seatRepository.findById(any())).thenReturn(Optional.of(ladiesSeat));

        BookingCreateRequest request = new BookingCreateRequest();
        request.setSeatId(ladiesSeat.getId().toString());

        // Act & Assert
        assertThrows(LadiesOnlySeatRestrictionException.class, () ->
                bookingService.createBooking(request, userWithoutGender.getId().toString())
        );
    }

    @Test
    void shouldAllowAllUsersToBookRegularSeats() {
        // Arrange
        User maleUser = new User();
        maleUser.setId(UUID.randomUUID());
        maleUser.setGender(Gender.MALE);

        Seat regularSeat = new Seat();
        regularSeat.setId(UUID.randomUUID());
        regularSeat.setIsLadiesOnly(false); // Regular seat
        regularSeat.setStatus("AVAILABLE");

        when(userRepository.findById(any())).thenReturn(Optional.of(maleUser));
        when(seatRepository.findById(any())).thenReturn(Optional.of(regularSeat));
        when(bookingRepository.save(any())).thenAnswer(i -> i.getArgument(0));

        BookingCreateRequest request = new BookingCreateRequest();
        request.setSeatId(regularSeat.getId().toString());

        // Act & Assert
        assertDoesNotThrow(() -> bookingService.createBooking(request, maleUser.getId().toString()));
    }

    @Test
    void shouldNotLockSeatIfValidationFails() {
        // Arrange
        User maleUser = new User();
        maleUser.setId(UUID.randomUUID());
        maleUser.setGender(Gender.MALE);

        Seat ladiesSeat = new Seat();
        ladiesSeat.setId(UUID.randomUUID());
        ladiesSeat.setIsLadiesOnly(true);
        ladiesSeat.setStatus("AVAILABLE");

        when(userRepository.findById(any())).thenReturn(Optional.of(maleUser));
        when(seatRepository.findById(any())).thenReturn(Optional.of(ladiesSeat));

        BookingCreateRequest request = new BookingCreateRequest();
        request.setSeatId(ladiesSeat.getId().toString());

        // Act
        try {
            bookingService.createBooking(request, maleUser.getId().toString());
        } catch (LadiesOnlySeatRestrictionException e) {
            // Expected
        }

        // Assert
        verify(seatRepository, never()).save(any());
        verify(bookingRepository, never()).save(any());
    }
}
```

### Integration Tests

```java
@SpringBootTest
@AutoConfigureMockMvc
class BookingApiIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private JwtUtils jwtUtils;

    @Test
    void shouldReturn403WhenMaleUserAttemptsToBookLadiesOnlySeat() throws Exception {
        // Mock JWT token extraction
        when(jwtUtils.extractUserId(anyString())).thenReturn("male-user-id");
        when(jwtUtils.extractGender(anyString())).thenReturn("MALE");

        // Perform booking request
        mockMvc.perform(post("/api/booking/create")
                .header("Authorization", "Bearer mock-jwt-token")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"seatId\":\"ladies-only-seat-id\",\"bookingDate\":\"2025-10-15\"}"))
                .andExpect(status().isForbidden())
                .andExpect(jsonPath("$.errorCode").value("LADIES_ONLY_SEAT_RESTRICTION"))
                .andExpect(jsonPath("$.message").value("This seat is reserved for female users only. Please select a different seat."));
    }

    @Test
    void shouldReturn200WhenFemaleUserBooksLadiesOnlySeat() throws Exception {
        // Mock JWT token extraction
        when(jwtUtils.extractUserId(anyString())).thenReturn("female-user-id");
        when(jwtUtils.extractGender(anyString())).thenReturn("FEMALE");

        // Perform booking request
        mockMvc.perform(post("/api/booking/create")
                .header("Authorization", "Bearer mock-jwt-token")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"seatId\":\"ladies-only-seat-id\",\"bookingDate\":\"2025-10-15\"}"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.bookingId").exists())
                .andExpect(jsonPath("$.message").value("Booking created successfully"));
    }
}
```

### PostgreSQL MCP Validation

```sql
-- Test 1: Verify ladies-only seat exists
SELECT id, seat_number, is_ladies_only
FROM seats
WHERE is_ladies_only = TRUE
LIMIT 1;

-- Test 2: Verify female user can book ladies-only seat
SELECT b.id, b.user_id, s.seat_number, s.is_ladies_only, u.gender
FROM bookings b
JOIN seats s ON b.seat_id = s.id
JOIN users u ON b.user_id = u.id
WHERE s.is_ladies_only = TRUE AND u.gender = 'FEMALE';

-- Test 3: Verify no bookings of ladies-only seats by non-female users
SELECT COUNT(*) AS invalid_bookings
FROM bookings b
JOIN seats s ON b.seat_id = s.id
JOIN users u ON b.user_id = u.id
WHERE s.is_ladies_only = TRUE AND u.gender != 'FEMALE';
-- Expected: 0 invalid bookings

-- Test 4: Verify seat remains available after failed validation
SELECT id, seat_number, status
FROM seats
WHERE is_ladies_only = TRUE AND status = 'AVAILABLE';
```

[Source: Sprint Change Proposal A, Section 11 - PostgreSQL MCP Validation]

---

## Definition of Done

- [ ] Backend validates gender before booking ladies-only seat
- [ ] Female users can book ladies-only seats
- [ ] Male users cannot book ladies-only seats (403 error)
- [ ] Users with OTHER/PREFER_NOT_TO_SAY cannot book ladies-only seats
- [ ] Users without gender cannot book ladies-only seats
- [ ] All users can book regular seats
- [ ] API returns 403 with clear error message
- [ ] Error response includes error code and seat ID
- [ ] Gender extracted from JWT token
- [ ] Invalid/expired JWT returns 401
- [ ] Validation occurs before seat lock
- [ ] Failed validation does not lock seat
- [ ] Failed validation does not create booking
- [ ] Failed attempts logged with user ID and seat ID
- [ ] Unit tests passing (95%+ coverage)
- [ ] Integration tests passing
- [ ] PostgreSQL MCP validation complete
- [ ] Zero invalid bookings in database
- [ ] API documentation updated (Swagger)
- [ ] Code reviewed and approved
- [ ] Stories 0.1.5-backend, 1.4.1, and 2.18.1 verified complete

---

## Dependencies & Blockers

### Blocked By:
- ⛔ Story 0.1.5-backend (Backend Gender Field) - MUST be complete
- ⛔ Story 1.4.1 (Ladies-Only Seat Configuration) - MUST be complete
- ⛔ JWT token includes gender claim

### Unblocks:
- ✅ Complete ladies-only seats feature (backend validation complete)
- ✅ End-to-end gender-based booking enforcement

[Source: Sprint Change Proposal A, Section 8 - Phase 4]

---

## Security Considerations

### Critical Security Points:
1. **JWT Token Validation**: Gender claim extracted from authenticated JWT only
2. **No Client-Side Bypass**: Backend validation enforced regardless of frontend validation
3. **Transaction Safety**: Validation occurs before seat lock to prevent race conditions
4. **Audit Trail**: All failed attempts logged for security monitoring
5. **Database Integrity**: PostgreSQL CHECK constraints provide additional safety net

### Threat Mitigation:
- **API Manipulation**: Backend validation prevents bypassing frontend checks
- **Token Tampering**: JWT signature verification ensures gender claim authenticity
- **Race Conditions**: Database-level seat locking prevents concurrent booking conflicts
- **Data Integrity**: Transactional booking ensures atomic operations

[Source: Sprint Change Proposal A, Section 10 - Security Considerations]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | Story created from Sprint Change Proposal A | Bob (SM) |

---

**Story Status**: Draft
**Last Updated**: 2025-10-14
**Next Steps**: Review with PO, verify all dependencies complete, assign to backend developer
